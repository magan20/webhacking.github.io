<!DOCTYPE html>
<html  lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>[20200225_TIL_07]</title>
    </head>
    <body>
        <h1>7. 세션 공격</h1>
        <ul>
            <li>대부분의 웹 애플리케이션은 세션을 통해 사용자의 요청을 구별, 처리한다.</li>
            <li>공격자가 세션관리를 뚫을 수 있으면 다른 사용자의 권한을 획득할 수 있음</li>
            <li>대부분의 취약점은 공격자가 애플리케이션으로부터 제공받은 고유 토큰의 값을 증가해서 다른 사용자의 권한을 얻을 수 있는 경우임</li>
            <li>이 장에서는 세션 관리에 대한 취약범과 세션 관리 취약점을 찾기 위한 일반적인 단계, 예방 방법에 대해 설명</li>
            <div>
                <h2>1. 사용자의 상태에 대한 유지 필요</h2>
                <ul>
                    <li>http 프로토콜은상태 정보를 지속적으로 가지고 있지 않음</li>
                    <li>htp 프로토콜은 사용자가 웹 애플리케이션에 특정 자원을 요청할 때 개별 사용자에게 요청에 대한 응답을 제공할 메커니즘을 가지고 있지 않음</li>
                    <li>웹 애플리케이션은 세션이라는 개념을 통해 이와 같이 개별적으로 사용자를 구분할 수 있음</li>
                    <li>세션이 사용되는 흔한 예는 로그인 부분임</li>
                    <li>일반적으로 각 사용자에게 유일한 세션 토큰이나 식별자를 부여해서 세션을 생성한다.</li>
                    <li>대부분 쿠키를 사용해서 서버와 클라이언트 간에 세션 토큰을 주고 받는다.</li>
                    <li>세션관리 매커니즘 취약점</li>
                    <ol>
                        <li>세션 토큰을 만드는 과정에서 발생하는 취약점</li>
                        <li>세션 토큰을 처리할 때 발생하는 취약점</li>
                    </ol>
                    <br>
                    <li>애플리케이션은 쿠키, URL, 매개변수, 히든 필드 등 수많은 항목의 데이터를 토큰으로 사용할 수 있다.</li>
                    <div>
                        <h3>1_1. 세션 대안</h3>
                        <ol>
                            <li><b>http 인증</b></li>
                            <ul>
                                <li>애플리케이션은 다양한 HTTP 기반의 인증 기법을 통해 세션을 사용하지 않을 수 있음</li>
                                <li>http Basic: 기본 액세스 인증, http 사용자가 에이전트 요청시 사용자 이름과 비밀번호를 제공하는 방법</li>
                                <li>http digest: 웹 서버가 사용자의 웹 브라우저와 사용자 이름 또는 암호와 같은 자격 증명을 협상하는 데 사용할 수 있는 합의된 방법</li>
                            </ul>
                            <br>
                            <li><b>비세션(Sessionless) 상태 메커니즘</b></li>
                            <ul>
                                <li>일부 애플리케이션은 쿠키나 보이지 않는 형식으로 클라이언트에게 상태를 관리하기 위한 데이터를 보낸다.</li>
                                <li>이렇게 함으로써 이 메커니즘은 ASP.NET Viewstate와 비슷한 비세션 상태를 사용할 수 있게 된다.</li>
                                <li>안전하게 상태 정보를 전달하기 위해 보통 바이너리를 만들어서 모든 상태 정보를 담고, 만들어진 바이너리를 암호화하거나 서명해서 사용</li>
                            </ul>
                            <br>
                        </ol>
                        <ul>
                            <li><p>http 인증을 사용하고 있는 애플리케이션이 있다면 세션 관리 메커니즘이 사용되지 않았을 가능성이 높다.</p></li>
                            <li><p>애플리케이션이 상태를 관리하는 데 세션 토큰을 사용하지 않으면 7장에서 소개하는 어떤 공격도 소용 없을 수 있다.</p></li>
                        </ul>
                    </div>
                </ul>
            </div>
            <div>
                <h2>2. 세션 토큰을 만드는 과정에서 발생하는 취약점</h2>
                <ul>
                    <div>
                        <h3>2_1. 중요한 토큰</h3>
                        <ul>
                            <li>세션 토큰은 사용자명이나 이메일 주소를 변경해서 만들어지기도 하고, 그 외의 다른 정보를 이용해서 만들어지기도 함</li>
                            <li>공격자를 디코딩해 이해하기 쉽게 만들어진 세션 토큰에서 원하는 내용을 바꿔서 다른 사용자의 세션을 알 수도 있다.</li>
                            <li>세션 토큰을 때로 중요한 데이터를 포함하고 있는 컴포넌트를 가지로 있는 경우도 있다.</li>
                            <ul>
                                <li>사용자 계정</li>
                                <li>사용자 실명</li>
                                <li>이메일 주소</li>
                            </ul>
                            <br>
                            <li>일반적으로 사용하는 인코딩 스키마는 XOR, Base64, 아스키 문자열을 사용한 16진법 등이 있다.</li>
                            <li>토큰을 작은 부분으로 나눠서 분석하면 토큰이 가지고 있는 복잡한 부분을 좀 더 쉽게 이해 할 수 있을 것이다.</li>
                            <li>애플리케이션의 세션을 필요로 하는 페이지(사용자 정보 페이지 등)에서 유효하지 않는 세션에 대한 에러메시지를 통해 유요한 세션을 찾을 수 있다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>2_2. 추측 가능한 토큰</h3>
                        <ul>
                            <li>일부 세션 코튼은 웹 애플리케이션 사용자와의 연관성이나 의미 있는 데이터를 전혀 포함하고 있지 않는 경우도 있음</li>
                            <li>토큰이 일정한 패턴을 가지고 있는 경우 공격자는 샘플을 수집해서 세션 토큰을 추측할 수 있는 경우도 있다.</li>
                            <li>상용 세션 관리 제품에서 자동화 공격을 통해 추측 가능한 세션 토큰과 관련된 취약점을 더 쉽게 찾아볼 수 있음.</li>
                            <li>애플리케이션의 세션 토큰이 좀 복잡하게 되어있는 경우 추측 가능한 세션 토큰은 보통 3가지 소스에서 나온다.
                                <ol>
                                    <li><b>숨겨진 시퀸스</b></li>
                                    <ul>
                                        <li>세션 토큰의 원래 형태에서 어떤 것도 추측할 수 없더라도 적절한 디코딩이나 언패킹을 하면 숨겨진 내용을 찾을 수 있는 경우도 있다.</li>
                                        <li>언패킹: 보호를 목적으로 암호화 및 암축된 실행파일을 원상태로 해제하는 것을 의미</li>
                                    </ul>
                                    <br>
                                    <li><b>시간 의존성</b></li>
                                    <ul>
                                        <li>어떤 토큰의 연속이 무작위로 나타나 있다고 해도 각 토큰이 만들어진 시간에 대한 정보와 쌍을 이루는 순서는 무언가 식별하 수 있는 패턴을 가지고 있을 것이다.</li>
                                        <li>시간과 관련된 알고리즘을 이용해서 토큰을 만드는 애플리케이션에서는 사른 사용자의 토큰을 구별하기 위해 스크립트 공격을 사용하면 성공할 가능성이 높다.</li>
                                        <li>세션 생성 알고리즘을 스크립트로 만들어서 범위안의 각 값에 무차별 대입 공격을 하면 다른 사용자의 세션을 얻을 수 있다.</li>
                                    </ul>
                                    <br>
                                    <li><b>약한 무작위 번호 생성</b></li>
                                    <ul>
                                        <li>의사 랜덤(pseudo-random): 난수를 흉내내기 위해 알고리즘으로 생성하는 알고리즘을 이용해서 만들어진 값, 알고리즘의 상태에 의해 값이 정해지므로 생성된 수열은 일정한 주기를 가지면 난수의 예측 불가능성을 가질 수 없다. </li>
                                        <li>세션 토큰을 생성하는 데 추측 가능한 의사 랜덤 숫자를 사용하면 취약한 토큰이 만들어진다.</li>
                                        <li>이런 알고리즘을 알고 그 알고리즘에서 생성된 숫자를 하나 알고 있다면 다음에 알고리즘이 만들어낼 숫자를 추측하는 일이나 이전에 생성된 연속된 숫자들을 알아내는 것은 어려운 일이 아니다.</li>
                                        <li>온라인 뱅크와 같은 보안이 철저한 애플리케이션을 성공적으로 공격하려면 Full-Blown메소드를 사용해 토큰이 얼마나 무작위로 생성되는지 테스트해 보아야 함.</li>
                                        <li>스톰피(stompy): 통계 분석 및 무차별 대입 공격을 견딜 수 있는 www 세션 식별자 또는 기타 토큰을 생셩하는 데 사용되는 알고리즘의 블랙 박스 평가를 수행 하는 도구</li>
                                    </ul>
                                </ol>
                            </li>
                        </ul>
                    </div>
                </ul>
            </div>
            <div>
                <h2>3. 세션 토큰을 처리할 때 발생하는 취약점</h2>
                <ul>
                    <li>애플리케이션이 토큰을 생성하는 데 취약점이 거의 없다고 해도 토큰이 생성된 후에 제대로 관리도지 않으면 세션 메커니즘은 공격자에게 취약점을 노출시킬 수 있다.</li>
                    <li>SSL을 제대로 활용하면 세션 토큰이 수집 당하지 않게 보호해 줌</li>
                    <li>SSL을 사용할 때 주의하지 않으면 토큰들이 문자 그대로 드러날 수도 있고, 공격자에게 다양한 공격을 허용할 수도 있다.</li>
                    <div>
                        <h3>3_1. 네트워크상의 토큰 노출</h3>
                        <ul>
                            <li>세션 토큰이 네트워크에서 암호화되지 않은 상태로 전송될 떄 노출 취약점이 발생하며 <b>'도청'</b>을 통해 다른 사용자의 토큰응ㄹ 얻을 수 있다.</li>
                            <li>대부분 도청을 하기 위한 장소는 ISP이다.</li>
                            <li>각 경우에 도청이 가능한 사용자로는 그 기관에 권한이 있는 사용자와 그 기관을 뚫으려는 외부 공격자가 있다.</li>
                            <li>일부 애플리케이션은 로그인할 때만 https를 사용하고 그 이후로는 남아있는 세션을 http를 이용하여 전송하는 경우가 있어서 토큰을 수집할 수 있다.</li>
                            <li>토큰 세션이 http로 넘겨질 때 공격자는 사용자의 세션 토큰을 가로챌 수 있다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>3_2. 로그에서 토큰 노출</h3>
                        <ul>
                            <li>다양한 종류의 시스템 로그에서도 토큰이 노출되기도 하는데 이런 경우에는 네트워크를 도청하는 공격자 뿐 아니라 더 많은 외부 공격자에게 토큰이 노출되기 때문에 결과는 더욱 심각해진다.</li>
                            <li>관리자 기능을 포함하고 있는 애플리케이션의 관리자 기능에는 다른 사용자의 세션과 애플리케이션 실시간 상태를 모니터링하는 기능이 있다. 또한 이런 기능은 가끔 제대로 보호되어있지 않기 때문에 권한을 부여받지 않은 사용자가 이런 기능을 사용할 수도 있다.</li>
                            <li>애플리케이션에서 토큰을 전송하는 메커니즘으로 HTTP 쿠키와 POST 요청의 바디를 사용하지 않고 URL 쿼리문자열을 사용하면 세션토큰이 여러곳에 노출되게 된다.</li>
                            <ul>
                                <li>자용자의 브라우저 로그들</li>
                                <li>웹서버 로그들</li>
                                <li>기업이나 ISP 프록시 서버들의 로그</li>
                                <li>애플리케이션의 호스팅에서 사용된 모든 리버스 프록시 로그들</li>
                                <li>오프 사이트 링트에 담겨있는 리퍼러 로그</li>
                            </ul>
                            <br>
                            <li>오프사이트: 사용되거나 일반적으로 발생하는 위치와 다른 위치에서 발생하거나 수행되는 것</li>
                            <li>SSL을 사용하고 있다고 해도 중요한 데이터를 URL애 둔다면 리퍼러 로그를 통해 누출될 가능성이 있다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>3_3. 세션에 대한 취약한 토큰 매핑</h3>
                        <ul>
                            <li>애플리케이션이 토큰을 생성해서 각 사용자에게 생성된 토큰을 매핑할 때 매핑하는 방법에 약점이 있기 때문에 세션 관리 메커니즘과 관련된 다양한 취약점이 생긴다.</li>
                            <li>동시에 한 사용자에게 여러 세션을 주는것은 공격자들이 발각될 일 없이 수집한 다른 사용자의 접근 권한을 마음대로 사용할 수 있는 기회를 주는 것이다.</li>
                            <li>정적인 토큰(static token): 이벤트가 발생할 때마다 바뀌는 토큰과는 다르게 변하지 않고 항상 같은 토큰이다.</li>
                            <li>정적인 토큰을 사용하는 애플리케이션</li>
                            <ul>
                                <li>정적인 토큰을 사용하는 애플리케이션에서는 각 사용자가 토큰을 부여받고 그 토큰은 사용자가 로그인할 때마다 다시 발행된다.</li>
                                <li>애플리케이션은 사용자가 최근에 로그인해서 새로운 토큰을 받았든지 말았든지 간에 항상 똑같은 토큰을 유효하게 취급</li>
                                <li>충분히 예상할 수 있을 정도로 정적인 토큰이 쉽게 만들어져 있으면 공격자는 고르인한 사용자의 세션뿐 아니라 다른 사용자의 토큰도 쉡게 추측해서 모든 사용자의 세션을 가로챌 수 있다.</li>
                                <li>여러개의 토큰을 동시에 사용할 수 있다는 것은 동시에 여러대의 컴퓨터에서 로그인 할 수 있다는 것을 의미</li>
                            </ul>
                        </ul>
                    </div>
                    <div>
                        <h3>3_4. 세션 종료의 취약점</h3>
                        <ul>
                            <li>세션 종료가 중요한 이유</li>
                            <ol>
                                <li>세션의 사용 기간을 짧게 할수록 공격자들이 유효한 세션 토큰을 수집하고, 추측하고, 악용하는 시간을 줄일 수 있다.</li>
                                <li>사용자들이 애플리케이션을 한동안 사용하지 않으면 세션을 종료함으로써 공유된 환경에서 사용하고 있는 사용자의 열려 있는 창을 다른 사용자가 더 이상 사용하지 못하게 보호한다.</li>
                            </ol>
                            <br>
                            <li>세션 종료를 효과적으로 하지 않는 애플리케이션</li>
                            <ul>
                                <li>로그아웃 기능이 없는 애플리케이션->사용자들을 자신의 세션을 종료할 방법이 없다.</li>
                                <li>로그아웃 기능은 있지만 서버가 제대로 세션을 종료하지 않는 경우->브라우저로부터 토큰을 없애지만 로그아웃 후에도 토큰을 전송한다면 서버는 그 토큰을 계속 받아들인다.</li>
                                <li>로그안웃을 해도 요청이 서버로 전송되지 않는 경우->공격자가 사용자의 쿠키를 얻게 된다면 해당 애플리케이션을 계속해서 사용할 수 있다.</li>
                            </ul>
                        </ul>
                    </div>
                    <div>
                        <h3>3_5. 토큰 하이재킹에 대한 클라이언트 노출</h3>
                        <ul>
                            <li>세션 하이재킹: 시스템에 접근할 적법한 사용자 아이디와 패스워드를 모를 경우 공격 대상이 이미 시스템에 접속되어 세션이 연결되어 상태를 가로채기 하는 공격으로 아이디와 패스워드를 몰라도 시스템에 접근하여 자원이나 데이터를 사용할 수 있는 공격</li>
                            <li>애플리케이션에서 공격자들이 세션 토큰을 수집하거나 악용하는 방법</li>
                            <ul>
                                <li>크로스 사이트 스크립팅 공격 코드를 만들어 사용자의 쿠키를 요청한 다음에 공격자가 통제 가능한 조작된 서버로 사용자의 세션을 전송하게 하는 방법이 있다.</li>
                                <li>세션 고정에 대한 취약점: 공격자가 사용자에게 알려진 세션토큰을 준 다음 사용자가 로그인할 떄까지 기다렸다가 사용자가 로그인을 할 때 세션을 가로채는 것</li>
                                <li>크로스사이트 요청 위조공격: 공격자가 통제할 수 있는 웹사이트의 애플리케이션에 미리 특정 요청을 만들어둔 다음 사용자가 현재 쿠키를 전송할 때 사용자의 브라우저는 자동적으로 이 요청과 함꼐 전송하는 방법</li>
                            </ul>
                        </ul>
                    </div>
                    <div>
                        <h3>3_6. 개방적인 쿠키 범위</h3>
                        <ul>
                            <li>쿠키가 사용되는 방법</li>
                            <ul>
                                <li>서버가 HTTP 응답 헤더 Set-Cookie를 사용하여 쿠키를 발행하고 브라우저는 다시 이 쿠키를 Cookies 헤더를 사용해서 서버에게 전송</li>
                            </ul>
                            <br>
                            <li>쿠키 메커니즘은 서버가 각 쿠키가 재전송될 도메인과 URL 경로를 구분할 수 있게 해줌->Set-Cookie 안에 포함되어 있는 도메인과 경로 속성을 이용</li>
                        </ul>
                        <br>
                        <ol>
                            <li><b>쿠키 도메인 제한</b></li>
                            <ul>
                                <li>어느 도메인에 있는 애플리케이션이 쿠키를 만든다면 브라우저는 기본적으로 쿠키가 만들어진 도메인과 그 하위 도메인에게만 쿠키를 전송</li>
                                <li>어느 도메인에서 쿠키가 만들어지면 상위 도메인이나 서브 도메인에게는 쿠키를 전송하지 않음</li>
                                <li>Set-Cookie 헤더에서 domain 속성을 이용하여 도메인의 범위를 지정할 수 있다.</li>
                                <li>domain 속성에 기술된 도메인은 .com이나 .co.uk처럼 최상위 도메인일 수 없다.</li>
                                <li>쿠키 도메인의 범위를 너무 넓게 정할 경우 쿠키나 토큰이 탈취되었을 때 여러 하위 도메인에 접근이 허용될 수 있다.</li>
                            </ul>
                            <br>
                            <li><b>쿠키 경로 제한</b></li>
                            <ul>
                                <li>애플리케이션은 쿠키 범위를 정할 떄 도메인에 대한 제한과 함께 경로(path) 속성을 Set-Cookie 명령에 포함시켜서 사용할 수 있다.</li>
                            </ul>
                        </ol>
                    </div>
                </ul>
            </div>
        </ul>
        <br>
        <br>
        <div>
            <h3> 중요</h3>
            <ol>
                <li>애플리케이션은 세션을 통해서 각 사용자의 요청을 구별하고 처리한다.</li>
                <li>애플리케이션은 세션이라는 개념을 통해 각 사용자를 개별적으로 구별할 수 있음-> 세션을 이용하여 각 사용자를 구별(세션 토큰을 이용해서 구별하는 것이 아님)</li>
                <li>일반적으로 각 사용자에게 유일한 세션 토큰을 발행해 세션을 생성한다.</li>
                <li>쿠키를 이용하여 세션 토큰을 즈고 받는다. 세션 토큰을 발생해 세션을 생성한다.</li>
                <li>세션 토큰을 이용해서 토큰을 확인한 후 유요한 세션 성립</li>
                <li>애플리케이션은 세션 토큰을 요청자가 애플리케이션과 어떤 유효한 세션을 성립했다는 것을 알리기(확인하기) 위해 사용</li>
                <li>세션 토큰을 이용하여 세션을 생성, 사용자와의 유효성 확인, 유효한 세션이면 사용자의 권한을 부여, 세션이 만료될 때까지 권리 사용</li>
                <li>쿠키는 애플리케이션이 만듬</li>
            </ol>
        </div>
        <div>
            <h3>questions</h3>
            <ul>
                <li>쿠키에서 세션 토큰을 받고 세션 토큰을 이용하여 세션을 생성하는게 맞나?</li>
                <li>세션으로도 사용자를 구별할 수 있고, 토큰으로도 사용자를 구별할 수 있나?</li>
                <li>애플리케이션이 세션 토큰을 통해 세션을 생셩하면 클라이언트와는 토큰을 통해 요청을 주고 받는 것인가? 즉 세션은 이동하지 않는 것인가?</li>
                <li>2_2_숨겨진 시퀀스에서, 이전의 하나에서 각 숫자를 빼본다는게 무슨 뜻인가?</li>
                <li>2_2_약한 무작위 번호 생성에서, full-blown 메소드가 무엇인가?</li>
                <li>3_2 에서, 오프사이트가 뭐임->리퍼러 헤더에 저장되는 Url에 해당되는 사이트인가?</li>
                <li>세션 고정이 정확하게 무엇인가?</li>
            </ul>
        </div>
    </body>
</html>