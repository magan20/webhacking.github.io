<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>[20200309_TIL_11]</title>
    </head>
    <body>
        <h1>11. 애플리케이션 로직 공격</h1>
        <ul>
            <li>모든 웹 애플리케이션은 내부 함수를 실행하기 위해 자테적으로 보유하고 있는 로직을 사용함</li>
            <li>애플리케이션의 로직 결함을 발견하기란 쉽지 않으며, 취약점에 대한 특징을 정의하기 어렵고 탐지하기 어려운 성향 떄문에 공격자는 로직 결함에 메우 큰 매력을 느낀다.</li>
            <div>
                <h2>1. 로직 결함의 특징</h2>
                <ul>
                    <li>sql인젝션이나 xss 취약점에 존재하는 코드 결함과 달리 로직 결함에는 일반적으로 발견되는 시그니처가 존재하지 않는다.</li>
                </ul>
            </div>
            <div>
                <h2>2. 현실적으로 존재하는 로직 결함</h2>
                <ul>
                    <li>로직 결함을 알아보는 가장 좋은 방법은 이론적으로 접근하기 보다 실제 예를 통해 알아보는 것임</li>
                    <li>로직 결함은 서로 많이 다르지만 서로 간에는 공통적인 면이 존재하며, 이런 로직 결함을 통해 개발자가 자주 저지르는 실수를 알 수 있다.</li>
                    <div>
                        <h3>2_1. 예제1: 취약한 비밀전호 변경 함수</h3>
                        <ul>
                            <div>
                                <h4>2_1_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션의 비밀번호 변경 함수는 사용자에 의해 수행됨</li>
                                    <li>이 함수에는 사용자가 입력란을 채웠는지, 비밀번호를 입력했는지, 새로운 비밀번호인지, 새로운 비밀번호를 확인했는지 등의 기능이 있어야 된다.</li>
                                    <li>관리자를 위해 비밀번호 병경 함수는 어떤 사용자든 사용자가 현재 사용하는 비밀번호를 입력하지 않고도 회원의 비밀번호를 변경할 수 있게 해줌</li>
                                    <li>이 두 함수는 서버 측의 스크립트 내에서 수행됨</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_1_2. 가정</h4>
                                <ul>
                                    <li>클라이언트 측 인터페이스에는 사용자인지 관리자인지를 구별해주는 요소가 존재함</li>
                                    <li>관리자 인터페이스는 클라이언트 측 인터페이스와 달ㄹ ㅣ현재 비밀번호를 확인하는 필드의 포함 여부를 확인하여 사용자인지 관리자인지 확인</li>
                                    <li>서버 측의 애플리케이션이 비밀번호를 변결할 떄 이 요청은 비밀번호 매개변수의 존재 유무에 따라 관리자로부터 온 것인지 일반 사용자로부터 온 것인지를 구별함. 즉 정상 사용자는 항상 현재 비밀번호 매개변수를 포함하고 있음</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_1_3. 공격</h4>
                                <ul>
                                    <li>앞에서 정해진 가정과 유사한 명백한 가정이 세워지면 로직 결함도 명백해진다.</li>
                                    <li>사용자는 자신이 요청하는 모든 값을 제어하는 것이 가능하기 떄문에 정상 사용자가 현재 비밀번호 매개변수를 포함하지 않는 요청을 할 수도 있다.</li>
                                    <li>해킹 단계</li>
                                    <ol>
                                        <li>로직 결함을 발견하기 위해 주요 함수를 면밀히 조사할 떄 입력되는 각 매개변수와 쿠키, 쿼리 문자 필드와 post 데이터 값을 차례대로 제거해본다.</li>
                                        <li>매개변수의 값뿐만 아니라 매개변수의 실제 이름까지도 제거됐음을 확인한다.</li>
                                        <li>애플리케이션이 허용하는 범위 내에 존재하는 모든 코드에 대해 한 번에 하나의 매개변수만 공격하게 한다.</li>
                                        <li>현재 조작하고 있는 요청이 다단계 처리 과정의 한 부분이라면 와선 단계까지 모든 과정을 따라가면서 실행해본다.</li>
                                        <br>
                                    </ol>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_2. 예제2: 체크아웃을 위한 절차(강제 검색 기술)</h3>
                        <ul>
                            <div>
                                <h4>2_2_1. 기능</h4>
                                <ul>
                                    <li>다음은 단계별로 주문을 하는 과정이다.</li>
                                    <ol>
                                        <li>상품 카테고리를 검색하고 선택한 아이템을 장바구니에 추가</li>
                                        <li>장바구니로 가서 주문을 승인</li>
                                        <li>결제 정보를 확인</li>
                                        <li>배달 정보를 확인</li>
                                        <br>
                                    </ol>
                                </ul>
                            </div>
                            <div>
                                <h4>2_2_2. 가정</h4>
                                <ul>
                                    <li>개발자는 사용자가 자신이 의도한 순서대로 각 단계에 접근할 것이라고 생각함으로 주문 절차를 모두 마친 사용자는 그 절차에 따라 세부 결제 정보 입력을 환료한 셈이 된다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_2_3. 공격</h4>
                                <ul>
                                    <li>사용자는 다단계 과정에서 몇단계를 건너 뛰고 바로 마지막 단계로 갈 수 있다.</li>
                                    <li>해킹 단계</li>
                                    <ol>
                                        <li>다단계 프로세스가 순차적인 요청으로 이뤄져 있을 떄 예상되는 순서를 벗어나는 요청을 보내본다,</li>
                                        <li>여러 url에 get이나 post 요청을 통해 순차적으로 접근하거나 동일한 url에 다른 매개변수 값을 입력함으로써 각 단계의 결과에 도달할 수 있을 것이다. 애플리케이션이 다른 단계에 접근하기 위해 사용하는 전체적인 메커니즘을 확싫; 이해하도록 한다.</li>
                                        <li>개발자가 내부 기능에 어떤 가정을 세웠는지 살펴보고, 어느 부분을 중점적으로 공격할 수 있을지에 대해 생각해본다. 애플리케이션 내에 비정상적인 행동을 유발하기 위해 세워진 가정을 위반하는 방법에 대해서도 알아보나디.</li>
                                        <li>다단계의 함수에 무작위로 접근할 경우 흔히 애플리케이션 내에 존재하는 다양한 예외사항에 부딪히게 된다. 그런 예외사항은 매개변수갸 null이나 초기화되지 않은 값일 경우 혹은 부분적으로 정의됐거나 모순된 상태일 경우 등 예즉하지 못하는 여러 행동이다. 이런 상황에서 애플리케이션은 현재 공격이나 그 외의 다른 공격에 응용할 수 있는 흥미로운 에러 메시지와 디버깅 결과를 돌려보낸다.</li>
                                        <br>
                                    </ol>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_3. 에제3: 보험 상품 위험성</h3>
                        <ul>
                            <div>
                                <h4>2_3_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션을 통해 사용자는 보험에 가입하기 위한 견적을 낼 수 있다.</li>
                                    <ol>
                                        <li>첫 단계에선 지우너자는 애플리케이션에 기본 정보를 입력하고, 어떤 보험 상품에 가입하기 원하는지, 원하는 요금은 얼마인지 기술한다.</li>
                                        <li>다음으로 지원자는 건강이나 직업 취미 생활 같은 다양한 개인 정보를 여러 단계에 걸쳐 입력한다.</li>
                                        <li>마직막으로 지원 서ㄹ는 보험사의 보험업자에게 전해진다. 보험업자는 세우바항을 검초하고 같은 웹 애플리케이션으로 서류를 받아들일지 아니면 추가적인 위험을 반영하기 위해 초기 구문을 수정할지 결정한다.</li>
                                        <br>
                                    </ol>
                                </ul>
                            </div>
                            <div>
                                <h4>2_3_2. 가정</h4>
                                <ul>
                                    <li>개발자는 사용자로부터 제공된 컴포넌트의 각 요청이 오직 html 형태로서 사용자로부터 요청받은 변수 값만을 포함할 것이라 생각한다.</li>
                                    <li>개발자는 애플리케이션을 구현할 때 사용자가 예상 밖의 변수를 입력한다면 어떤 일이 발생할지를 전혀 고려하지 않았다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_3_3. 공격</h4>
                                <ul>
                                    <li>사용자가 모든 요청에 악의적인 변수명이나 값을 삽입할 수 있기 떄문에 이전에 제시된 가정에는 분명 결함이 존재한다.</li>
                                    <ul>
                                        <li>공격자는 공유된 컴포넌트의 모든 서버 측 입력 값 검증을 우회함으로써 공격을 수행할 수 있었다.</li>
                                        <li>각 구문의 처리 단계에서 데이터에 대한 엄격한 검증이 수행됐고, 이런 검증 작업을 수행하지 않은 모든 데이터는 다음 단계로 넘어가지 못했다.</li>
                                        <li>그러나 공유된 컴포넌트는 애플리케이션의 상태를 사용자로부터 제공받은 모든 변수 값으로 업데이트 했으므로 공격자가 애플리케이션의 전 단계에서 예상했던 이름과 값의 쌍이 아닌 무작위 데이터를 입력했다면 애플리케이션은 검증 작업 수행 없이 데이터를 받아들이고 처리할 것이다.</li>
                                        <li>이런 일이 발생 했을 때 보험업자를 공격하려고 준비한 크로스사이트 스크립팅 공격이 가능해진다.</li>
                                        <br>
                                    </ul>
                                    <ul>
                                        <li>공격자는 입의의 조작된 가격으로 보험 상품을 구입할 수 있었다.</li>
                                        <li>첫 단계에서 지원자는 원하는 요금이나 가입을 원하는 보험 상품을 구체화했다. 그러나 사용자가 다음 단계에서 해당 항목에 새로운 값을 입력해ㅐㅆ다면 애플리케이션의 상태는 새로운 값으로 업테이트 될 것이다.</li>
                                        <li>이런 식으로 첫 단계에서 입력한 값과 다른 값을 다음 단계에 무작위로 입력함으로써 공격자는 보험 요금을 변경할 수 있었다.</li>
                                        <br>
                                    </ul>
                                    <ul>
                                        <li>위와 같이 프로세스 단계 중간에 사용자가 입력하는 변수 값에 대한 접근 제어가 존재하지 않았기 떄문에 사용자는 애플리케이션에 새로운 값을 입력할 수 있었다.</li>
                                        <li>보험업자가 지원서를 검토할 떄 사용하는 특정 변수명을 공격자가 알게 됐거나 추측할 수 있었다면 공격자는 단순히 이 변수명을 전송함으로써 보험업자를 거치지 않고 그들 소유의 지원서를 수락하는 것이 가능할 것이다.</li>
                                        <br>
                                    </ul>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_4. 예제4: 은행 털기 --- 이해 안됨 다시 읽어볼 것</h3>
                        <ul>
                            <div>
                                <h4>2_4_1. 기능</h4>
                                <ul>
                                    <li>대상 애플리케이션은 온라인 애플리케이션에 등록하지 않은 사용자가 거래를 하기 위해 애플리케이션에 새로운 사용자를 등록하게 요구했다.</li>
                                    <li>사용자의 정보가 애플리케이션상에 정확하게 입력됐을 때 애플리케이션은 사용자 등록을 휘애 백엔드 시스템으로 사용자가 입력한 정보를 전달한다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_4_2. 가정</h4>
                                <ul>
                                    <li>애플리케이션의 설계자는 이 메커니즘이 애플리케이션에 비인가된 접근에 대해 매우 강력한 방어 기능을 제공한다고 생각한다. 메커니즘은 다음과 같은 3단계로 보호된다.</li>
                                    <ol>
                                        <li>악의적 공격자가 다른 사용자를 도용하는 것을 막기 위해 사전에 충분한 사용자 정보를 요구했다.0</li>
                                        <li>애플리케이션의 프로세스는 고객이 등록한 집 주소로 주요 비밀 정보를 전송한다. 모든 공격자는 희생자의 개인 메일로 접근할 것이다.</li>
                                        <li>고객은 콜센터로 전화해서 개인 정보와 비밀번호를 통해 정상적인 방법으로 인증받아야 한다.</li>
                                    </ol>
                                    <li>이런 보호 메커니즘 설계는 강력하지만 실제로 실행하는 부분에 로직 결함이 존재한다.</li>
                                    <li></li>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_5. 예제5: 감사 흔적의 삭제</h3>
                        <ul>
                            <div>
                                <h4>2_5_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션은 직원이나 관리자가 광범위한 사용자 기능을 지원하고 관리하기 위해 헬프 데스크를 사용한다. 대부분의 기능이 계정 생성과 비밀번호 재설정 같은 보안적 요소에 민감하다.</li>
                                    <li>따라서 애플리케이션은 감사 흔적과 수행되는 모든 행위와 사용자의 신분을 신뢰한다는 기록을 보유하고 있다.</li>
                                    <li>관리자는 감사 흔적을 지울 수 있는데 악의적인 공격으로부터 애플리케이션의 감사 흔적을 지우는 행위를 막기 위해 모든 사용 히스토리가 기록되어야 한다.</li>
                                    <li>그러면 이로써 감사 흔적은 기록된 사용자의 신분을 신뢰한다는 것을 의미할 것이다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_5_2. 기능</h4>
                                <ul>
                                    <li>애플리케이션의 셜계자는 악의적인 사용자가 감사 흔적에 어떤 증거도 남기지 않고 올바르지 않은 행위를 하는 것은 불가능할 것이라고 생각했다.</li>
                                    <li>관리자가 감사 로그를 지우는 행위는 다른 사람들로부터 항상 의심받으며 손가락질 받게되는 마지막 흔적을 남기는 행위임이 분명하다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_5_3. 공격</h4>
                                <ul>
                                    <li>설계자의 가정에는 결함이 존재하는데, 관리 권한을 가진 악의적인 사용자는 감사 로그에 어떠한 흔적도 남기지 않고 임의의 작업을 수행하는 것이 가능하다.</li>
                                    <li>감사로그에 어떤 흔적도 남기지 않기 위해서는 다음 단계를 수행해야 한다.</li>
                                    <ol>
                                        <li>현재 소유한 계정을 이용해서 로그인하고 두 번쨰 사용자를 생성한다.</li>
                                        <li>1 단계에서 생성한 새로운 계정에 현재 소류하고 있는 모든 권한을 할당한다.</li>
                                        <li>1 단계에서 생성한 새로운 계정을 사용해서 의도하는 악의적인 행위를 수행한다.</li>
                                        <li>1 단계에서 생성한 새로운 계정을 사용해서 위의 세 산계에서 만들어진 모든 감사 로그를 삭제한다.</li>
                                        <br>
                                    </ol>
                                    <li>각 동작은 감사 로그에 입력되지만 마지막 단계에서 공격자는 앞에서 일어난 행동으로 생긴 감사 로그의 모든 입력 값을 삭제한다.</li>
                                    <li>그러면 감사 로그에는 어떤 로그 입력이 특정 사용자에 의해 지워졌다는 것을 보여주는 하나의 의심스러운 내용이 기록되는데, 이는 공격자에 의해 생섣된 새로운 계정에 의한 것이다.</li>
                                    <li>그러나 이전 로그 입력이 모두 지워졌기 떄문에 공격자를 의심스럽게 여길만한 어떤 것도 남지 않는다.</li>
                                </ul>
                            </div>
                            <li>이런 결함 유형은 보안이 중요시되는 2차적인 인증 방식이 요구되는 보안 모델에서 찾을 수 있다.</li>
                            <li>공격자가 새로운 계정을 생성하는 것이 가능하고, 그 후 그가 행할 악의적인 조작을 위해 2차적인 인증을 하는 데 새로 생성한 계정을 사용한다면 보안 모델에서 제공하는 추가적인 방어를 쉽게 우회할 수 있다.</li>
                            <li>감사 흔적 기록을 삭제하는 능력 없이는 감사 흔적 기록을 삭제할 수 없는데, 다른 강력한 사용자 계정을 생성하는 능력은 범인을 확인하기 위한 경우의 수를 너무 많이 제공하기 떄문에 감사 흔적을 추적하기 어렵게 만들 것이다.</li>
                            <li>감사 로그(감사 추적): 측정 작업, 절차 또는 이벤트에 영양을 미친 일련의 활동에 대한 문서 증거를제공하는 보안 관련 시간 기록, 레코드 세트 또는 대상 및 레코드 소스</li>
                        </ul>
                    </div>
                    <div>
                        <h3>2_6. 예제6: 비지니스 기능 제한의 파괴</h3>
                        <ul>
                            <div>
                                <h4>2_6_1. 기능</h4>
                                <ul>
                                    <li>재무 파트 직원은 회사 소유의 다양한 은행계좌와 주요 고객, 공급업자들 사이에서 자금 이체를 할 수 있다.</li>
                                    <li>사기에 대한 예방 조치로 애플리케이션은 대부분의 사용자들이 10000달러보다 큰 액수를 전송하는 것을 제한한다. 그보다 큰 액수를 전송하려면 상위 관리자의 승인이 필요하다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_6_2. 가정</h4>
                                <ul>
                                    <li>애플리케이션 내에서 이런 액수에 대한 제한을 검사하는 코드는 매우 단순하다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_6_3. 공격</h4>
                                <ul>
                                    <li>개발자는 사용자가 마이너스 값을 전송하는 것이 가능하다는 사실을 간과했기 때문에 이런 가정에는 결함이 존재한다. 입력된 마이너스 값이 임계치보다 적기 떄문에 이 값은 테스트를 우회할 것이다.</li>
                                    <li>해킹 단계</li>
                                    <ul>
                                        <li>비즈니스적인 측면의 제한을 무너뜨리는 첫번째 시도는 여러분이 제어하고 있는 관력된 입력 값 내에 어떤 문자 값이 허용되고 있는지를 이해하는 것이다.</li>
                                        <li>부적합한 값을 입력해보고 예상한 대로 애플리케이션에 의해 허가되고 처리되는지 살펴본다.</li>
                                        <li>의도한 목적으로 애플리케이션을 악용하기 위해 애플리케이션의 상태 변화를 꾀하는 여러 단계를 수행할 필요가 있다.</li>
                                    </ul>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_7. 예제7: 대량 구매 할인 시 존재하는 결함</h3>
                        <ul>
                            <div>
                                <h4>2_7_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션은 사용자가 소프트웨어 제품을 주문하고 몇 개 이상의 제품을 구매했을 떄 할인받게 한다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_7_2. 기능</h4>
                                <ul>
                                    <li>사용자가 장바구니에 아이템을 추가할 떄 해당 사용자가 할인 혜택을 받을 수 있는지 없는지 결정하기 위해 애플리케이션은 다양한 규칙을 사용한다.</li>
                                    <li>할인을 받을 수 있다면 장바구니에 들어있는 관련 아이템들의 가격은 할인된 가격으로 조정된다.</li>
                                    <li>개발자는 사용자가 선택된 묶음을 그대로 구입하고 할인을 받을 것이라고 짐작한다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_7_3. 공격</h4>
                                <ul>
                                    <li>개발자의 가정에는 분명한 결함이 있고, 사용자가 자신의 장바구니에서 추가한 아이템을 일부 제거할 수 있다는 가정을 무시하고 있다.</li>
                                    <li>교묘한 사용자는 가능한 많은 할인을 받기 위해 방바구니의 모든 상품을 대량으로 선책해 할인된 가격으로 추가할 수 있다.</li>
                                    <li>이렇게 할인 혜택을 받은 후 장바구니에서 원하지 않는 아이템을 지울 수 있고 남겨진 아이템에 대해서는 여전히 할인 혜택을 받을 수 있다.</li>
                                    <li>해킹 단계</li>
                                    <ol>
                                        <li>사용자에 의해 결정된 표준에 기반해 가격이나 다른 값이 조절된 상황에서 처음 애플리케이션에 의해 사용된 알고리즘을 이해하고, 로직 내의 어느 부분이 변경가능한지 살펴본다.</li>
                                        <li>창의적으로 생각해본다. 설계자가 의도한 것과 다르게 애플리케이션을 조작하는 방법을 찾기 위해 시도를 해본다. 앞서 설명한 것과 같이 이는 단순히 장바구니에서 할인 혜택을 모두 적용 받은 후 아이템을 지우는 것이다.</li>
                                    </ol>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_8. 예제8: 이스케이프의 회피</h3>
                        <ul>
                            <div>
                                <h4>2_8_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션에서 설계자는 사용자 제어할 수 있는 입력 값을 인수로 해서 운영체제에 넘기는 기능을 수행했다.</li>
                                    <li>애플리케이션은 입력값의 위험성을 인지하고 있었고, 사용자 입력값 내에 잠재적으로 위험이 있는 문자를 걸러냄으로써 이런 위험을 방어하고 있었다.</li>
                                    <li>이스케이프된 데이터는 쉘 명령어 해석기에 의해 인수의 한 부분으로써 다루게 하는데, 이는 추가적인 명령이나 인수, 재전송된 결과 등을 삽입하는 데 사용하는 쉡 메타캐릭터보다 낫다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_8_2. 가정</h4>
                                <ul>
                                    <li>개발자는 명령어 인젝션 공격을 막기 위해 강력한 방어 대책어르 적용했다고 확신했다.</li>
                                    <li>공격자가 입력할 만한 모든 문자에 대해 브레인스토밍 했으며 모두 적절히 이스케이프 했다. 그래서 안전할 것이라고 확신했다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_8_3. 공격</h4>
                                <ul>
                                    <li>개발자는 이스케이프 문자 자체를 이스케이프하는 것을 미처 생각하지 못했다.</li>
                                    <li>백슬래시 문자는 보통 단순한 명렁어 인젝션 취약점을 악용하는 경우 공격자에게 직접적으로 사용되지 않는데, 개발자는 이런 백슬래시 문자를 이스케이프하지 못하면 공격자에게 불순물 제거 메커니즘을 헛되게 만드는 방법을 제공하는 셈이 될 것이다.</li>
                                    <li>해킹 단계</li>
                                    <ul>
                                        <li>애플리케이션에 명령어 인젝션이나 다른 결함이 있는지 면밀히 조사할 때 사전에 설명된 로직 결함을 테스트하기 위해 데이터 값으로 메타 문자를 삽입하면 그 즉시 해당 문자 앞에 항상 백 슬래시가 붙게 된다.</li>
                                    </ul>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_9. 예제9: 검색 기능 악용</h3>
                        <ul>
                            <div>
                                <h4>2_9_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션은 회사 기록, 계정, 보도 자료, 시장 분석과 같은 역사적으로 거대한 아카이브와 현재 정보를 제공했다.</li>
                                    <li>아카이브: 다수의 파일을 압축해 하나로 모은 것</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_9_2. 가정</h4>
                                <ul>
                                    <li>애플리케이션에서 설계자는 사용자가 검색 기능을 사용해선 유용한 정보를 추출해 낼 수 없다고 가정했다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_9_3. 공격</h4>
                                <ul>
                                    <li>검색 기능은 숫자를 포함하여 요청한 쿼리와 일치하는 문서를 보여주기 떄문에 교묘한 사용자는 많은 수의 검색 결과를 보여주는 쿼리를 만들 수 있고, 검색 기능으로부터 유료 정보를 추출하기 위한 추정을 할 수도 있다.</li>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_10. 예제10: 디버그 메시지의 착취</h3>
                        <ul>
                            <div>
                                <h4>2_10_1. 기능</h4>
                                <ul>
                                    <li>금융 서비스 회사에서 사용하는 웹 애플리케이션은 최근에 설치되었으며, 여러 기능면에서 여전히 버그를 포함하고 있는 새로운 소프트웨어이다.</li>
                                    <li>애플리케이션의 다양한 명령은 가끔 예상치 않게 실패하는 경우가 있으며, 애플리케이션은 사용자에게 에러 메시키를 보여 줄 것이다.</li>
                                    <li>에러 결과에 대한 이해를 돕기 위해 개발자는 에러 메시지에 세부적인 많은 정보를 포함하기로 결정했다.</li>
                                    <li>헬프 데스크 직원이 시스템 실패의 원인을 조사하고 시스템복구를 시도할 떄 에러 메시지는 쓰모 있으며, 남은 기능적 버그를 제거하는 작업에 도움이 된다는 사실이 증명되었다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_10_2. 가정</h4>
                                <ul>
                                    <li>공격자는 사용자의 브라우저에서 진행되는 요청과응답을 면밀히 관찰함으로써 디버깅 메시지 내에 포함된 모든 정보를 쉽게 획득할 수 있다.</li>
                                    <li>메시지는 실제 실패 내역, 스택 추적에 대한 모든 세부사항을 담고 있지 않기 떄문에 애플리케이션에 대한 공격을 마음먹은대로 조직화 할 수 있다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_10_3. 공격</h4>
                                <ul>
                                    <li>에러가 발생했을 떄 애플리케이션의 컴포넌트는 필요한 모든 정보를 모으고 그것을 저장한다.</li>
                                    <li>사용자는 이 저장된 정보가 보여주는 URL로 HTTP 리다이렉트된다. 이 때 두 가지 측면에서 문제가 된다.</li>
                                    <li>애플리케이션의 디버그 정보 저장과 사용자가 에러 메시지로 접근한다는 것이 세션 기반이 아니라는 점이다. 더 정확히 말하자면 디버깅 정보는 고정된 공간에 저장되고 에러 메시지 URL은 항상 이 컨테이너 내에 위치된 정보를 보여줬다.</li>
                                    <li>개발자는 리다이렉트되는 사용자가 항상 자신의 에러에 관련된 디버스 정보만 볼 것이라고 생각했다.</li>
                                    <li>사실 이 경우에는 두 가지 에러가 거의 동시에 일어나기 떄문에 정상적인 사용자는 상황에 따라 다른 사용자의 에러와 관련된 디버깅 정보를 보게 된다. 이런 상황에서 스레드 안전성은 문제가 되지 않았고, 단순한 레이스 컨디션도 아니었다.</li>
                                    <li>스레드: 어떤한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이 경우 멀티스레드라고 한다.</li>
                                    <li>스레드 안전: 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻함. 보다 엄밀하게 하나의 함수가 한 스레드로부터 호출되어 실행 중일 떄, 다른 스레드가 그 함수를 호촐하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바르게 나오는 것을 의미한다.</li>
                                    <li>레이스 컨디션(경쟁 상태): 둘 이상의 입력 또는 조작의 타이밍이나 순서 들이 결과값에 영향을 줄 수 있는 상태를 말한다. 입력 변화의 타이밍이나 순서가 예상과 다르게 작동하면 정상적인 결과가 나오지 않게 될 위험이 있는데 이를 결쟁 위험이라고 한다.</li>
                                    <li>관리자가 세부적인 에러 메시지를 받았기 떄문에 에러 메시지를 모니터링하는 공격자는 전체 애플리케이션을 위협하는 충분한 정보를 획득할 수 있다.</li>
                                    <li>해킹 단계</li>
                                    <ol>
                                        <li>에러 메시지를 노출시키는 결함을 탐지하기 위해 비인가적인 이벤트와 상태를 방생시키게 할 수 있고, 정상적이지 않은 방법으로 반환되는 에러 메시지 같은 흥미로운 사용자 세부 정보를 브라우저로 발생시킬 수 있따.</li>
                                        <li>시스템적으로 두 사용자가 애플리케이션을 동시에 사용해서 다른 사용자가 각기 다른 상황에 영향을 받는지 살펴본다.</li>
                                    </ol>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>2_11. 예제11: 로그인 경쟁</h3>
                        <ul>
                            <div>
                                <h4>2_11_1. 기능</h4>
                                <ul>
                                    <li>애플리케이션은 접근 권한을 업기 위해 인증서를 제출해야 하는 사용자에게 여러 단계의 강력한 로그인 프로세스를 수행하게 요구했다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_11_2. 가정</h4>
                                <ul>
                                    <li>인증 메커니즘은 다양한 설계 검초와 모의 해킹 테스트를 거쳐 구현됐다. 개발자는 인증서를 소유한 사용자가 비인가적인 접근을 위해 메커니즘을 공격할 수 있는 뾰족한 방법이 없다고 자부했다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>2_11_3. 공격</h4>
                                <ul>
                                    <li>해킹 단계</li>
                                    <ul>
                                        <li>보안이 가장 중요시 되는 애플리케이션에서 부분적인 스레드 안정정을 위해 이런 종유의 원격 블랙박스 테스팅을 수행하는 것은 간단한 문제가 아니며, 전문적인 비즈니스 영역으로 인식돼야 한다.</li>
                                        <li>로그인 메커니즘, 비밀번호 변경 기능, 자금 이체 기능과 같은 주요 기능을 목표로 설정</li>
                                        <li>요청을 받은 사용자에 의해 단일 액션이 수행될 수 있는데, 확실한 결과를 낼 수 있는 가장 단순한 방법을 찾아낸다. 주어진 사용자로 로그인하는 것은 그들의 계정 정보로 접근해 확실한 결과를 가져오는 하나의 예시다.</li>
                                        <li>고사양 메커니즘을 사용해서 다른 네트워크 지역에서 애플리케이션에 접근해 다른 사용자들 대신 같은 행동을 반복적으로 수행하는 공격을 한다. 이런 각 작업이 예상된 결과를 가져오는지 여부를 확인한다.</li>
                                        <li>블랙박스 테스트: 소프트웨어 검사 방법 중 하나로 어떤 소프트웨어를 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 방법이다.</li>
                                        <br>
                                    </ul>
                                </ul>
                            </div>
                        </ul>
                    </div>
                </ul>
            </div>
            <div>
                <h3>3. 논리 결함 회피</h3>
                <ul>
                    <li>웹 애플리케이션에서 로직 결함을 쉽게 찾을 수 없는 것처럼 방어하기 위한 확실한 대응책도 없다.</li>
                    <li>하지만 애플리케이션에서 로직 결함 위험을 줄여줄 수 있는 구현 가능한 벙법들은 다양하다.</li>
                    <ul>
                        <li>애플리케이션 설계에서 다른 사람이 설계자에 의해 세워진 모든 가정을 쉽게 이해할 수 있게 애플리케이션 결계가 깔끔하게 세부적으로 문서화되어있어야 한다.</li>
                        <li>모든 소스코드가 다음 정보를 포함하도록 명확하게 주석처리한다.</li>
                        <ul>
                            <li>각 코드 컴포넌트의 목적과 의도된 사용</li>
                            <li>직접적인 제어를 받지 않는 모든 것에 대해 각 컴포넌트들에 의해 세워진 가정</li>
                            <li>컴포넌트를 사용하게 하는 모든 고객 코드를 참조한다. 이런 영향이 미치는 요소에 대한 명확한 문서화는 온라인 등록 기능에 존재하는 로직 결함을 막을 수 있다.</li>
                            <br>
                        </ul>
                        <li>애플리케이션을 설계할 떄 보안을 고려해서 검토가 이뤄지는 동안 설계에 이뤄진 모든 가정을 반영했음에도 불구하고 각 가정을 위반해 발생하는 치명적인 상황을 생각해본다.</li>
                        <li>보안을 고려한 코드 검토가 이뤄지는 동안 다른 두 가지 주요한 사항에 대해 논리적으로 생각해 본다.</li>
                        <ol>
                            <li>예측되지 않은 사용자 행동과 입력 값이 애플리케이션에 의해 제어되는 것</li>
                            <li>여러 코드 컴포넌트와 애플리케이션 기능 사이에 독립적인 내부 조작에 의해 잠재적으로 남겨진 영향</li>
                            <br>
                        </ol>
                        <br>
                    </ul>
                </ul>
            </div>
        </ul>
    </body>
</html>